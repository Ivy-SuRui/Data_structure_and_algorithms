### Sequence (Abstract Data Type) Interface

| Data Structure         | `get_at(i)`  | `set_at(i, x)` | `insert_first(x)` | `insert_last(x)` | `insert_at(i, x)` | `delete_first()` | `delete_last()` | `delete_at(i)` | Real-Life Example                             | Why Use It                                                                                  |
|------------------------|--------------|----------------|--------------------|------------------|--------------------|------------------|------------------|----------------|------------------------------------------------|---------------------------------------------------------------------------------------------|
| **Array**              | O(1)         | O(1)           | O(n)               | O(n)             | O(n)               | O(n)             | O(n)             | O(n)           | Fixed-size grids (e.g., chessboard, 2D games) | Use when **size is fixed** and **fast access** is needed. Memory layout is predictable.     |
| **Linked List**        | O(n)         | O(n)           | O(1)               | O(n)             | O(n)               | O(1)             | O(n)             | O(n)           | Text editor undo/redo, browser history stack   | Use when **frequent insert/delete at front or middle**; don’t need fast indexing.           |
| **Dynamic Array**      | O(1)         | O(1)           | O(n)               | O(1)* (amortized)| O(n)               | O(n)             | O(1)* (amortized)| O(n)           | Chat apps, dynamic to-do lists, playlists      | Use when **list size changes often**; fast average-case appends; auto-resizing is helpful.  |
| **Binary Tree (in-order)** | O(n)     | O(n)           | O(log n)           | O(log n)         | O(log n)           | O(log n)         | O(log n)         | O(log n)       | Document outlines, compiler parse trees        | Use when data has **hierarchical structure** or needs **sorted traversal**                  |
| **AVL Tree (augmented)**  | O(log n)   | O(log n)       | O(log n)           | O(log n)         | O(log n)           | O(log n)         | O(log n)         | O(log n)       | Ranked search results, collaborative editors   | Augmented for **fast positional access and modification**, always **balanced**              |

### Set Interface

| Data Structure         | `build(A)`     | `find(k)`      | `insert(x)`     | `delete(k)`     | `find_min()`   | `find_max()`   | `find_prev(k)` | `find_next(k)` | Real-Life Example                              | Why Use It                                                                                      |
|------------------------|----------------|----------------|------------------|------------------|----------------|----------------|----------------|----------------|------------------------------------------------|--------------------------------------------------------------------------------------------------|
| **Unordered Array**    | O(n)           | O(n)           | O(n)             | O(n)             | O(n)           | O(n)           | O(n)           | O(n)           | Small shopping cart, basic membership check     | Easy to implement, but slow for large data or frequent updates.                                |
| **Sorted Array**       | O(n log n)     | O(log n)       | O(n)             | O(n)             | O(1)           | O(1)           | O(log n)       | O(log n)       | High score tables, sorted product lists         | Efficient **search** and **ordering**, but slow **inserts/deletes**.                           |
| **Direct Access Array**| O(u)           | O(1)           | O(1)             | O(1)             | O(u)           | O(u)           | O(u)           | O(u)           | Bitmap flags, counting sort buckets             | Lightning-fast lookups when universe `u` is small and known.                                   |
| **Hash Table**         | O(n) (expected)| O(1)*          | O(1)*            | O(1)*            | O(n)           | O(n)           | O(n)           | O(n)           | User login system, dictionary, cache store      | Fast average-case performance; no ordering; relies on good hash functions.                     |
| **Binary Search Tree** | O(n)           | O(h)           | O(h)             | O(h)             | O(h)           | O(h)           | O(h)           | O(h)           | Autocomplete, dynamic contact list              | Maintains order with **log-time operations** if balanced; unbalanced trees degrade to O(n).    |
| **AVL Tree**           | O(n log n)     | O(log n)       | O(log n)         | O(log n)         | O(log n)       | O(log n)       | O(log n)       | O(log n)       | Live leaderboard ranking, time-based alerts, calendar     | **Always balanced**, so worst-case remains **logarithmic** for all operations.                |

\* Expected average-case time; may degrade to O(n) in worst-case scenarios (e.g., hash collisions).  
**Note:** `u` = size of the **key universe** (i.e., the total range of possible keys — like 0 to 10⁶). Large `u` = higher memory cost.

\* When we talk about runtime for building a data structure, we assume the programmers take an efficient algorithm.



### Comparison of Classic Sorting Algorithms

| **Category**              | **Algorithm**     | **How It Works**                                                        | **Time Complexity**                             | **Space**            | **Stable?** | **In-Place?** | **Use Case Example**                                            | **Why Use It**                                                                 |
|---------------------------|-------------------|-------------------------------------------------------------------------|--------------------------------------------------|----------------------|-------------|----------------|------------------------------------------------------------------|----------------------------------------------------------------------------------|
| Simple / Quadratic        | **Bubble Sort**   | Repeatedly swaps adjacent elements if they are in the wrong order       | Best: O(n), Avg: O(n²), Worst: O(n²)             | O(1)                 | Yes         | Yes            | Educational tools, lists that are nearly sorted                  | Very easy to implement; good for small or mostly sorted inputs                  |
| Simple / Quadratic        | **Selection Sort**| Repeatedly selects the minimum element and moves it to the front        | Best: O(n²), Avg: O(n²), Worst: O(n²)            | O(1)                 | No          | Yes            | Tight memory situations, basic sorting demos                     | Very simple and minimal memory, but inefficient for large datasets              |
| Simple / Quadratic        | **Insertion Sort**| Builds the sorted list by inserting elements into their correct position| Best: O(n), Avg: O(n²), Worst: O(n²)             | O(1)                 | Yes         | Yes            | Live data streams, nearly sorted arrays                          | Efficient for small, partially sorted data or online insertions                 |
| Divide & Conquer          | **Merge Sort**    | Recursively divides array, then merges sorted halves                    | Best: O(n log n), Avg: O(n log n), Worst: O(n log n) | O(n)             | Yes         | No             | Sorting linked lists, external sorting (large files)             | Stable, consistent performance, good for large or structured data               |
| Divide & Conquer          | **Quick Sort**    | Partitions array around a pivot and recursively sorts partitions        | Best: O(n log n), Avg: O(n log n), Worst: O(n²)  | O(log n) (stack)     | No          | Yes            | General-purpose fast sorting                                     | Very fast in practice; widely used in standard libraries                        |
| Heap-based                | **Heap Sort**     | Builds a heap and repeatedly extracts the max or min                    | Best: O(n log n), Avg: O(n log n), Worst: O(n log n) | O(1)              | No          | Yes            | Priority queues, embedded systems                                | No extra memory needed; consistent O(n log n) performance                       |
| Counting-based (Linear)   | **Counting Sort** | Counts occurrences of each key and computes position directly           | Best: O(n + k), Avg: O(n + k), Worst: O(n + k)   | O(k)                 | Yes         | No             | Sorting small integer ranges (e.g. exam scores, ages)            | Lightning fast when key universe is small; not comparison-based                 |
| Counting-based (Linear)   | **Radix Sort**    | Sorts by individual digits or characters, one position at a time        | Best: O(nk), Avg: O(nk), Worst: O(nk)            | O(n + k)             | Yes         | No             | Phone numbers, zip codes, strings with fixed-length characters   | Efficient non-comparison sort for structured keys                              |
| Counting-based (Linear)   | **Bucket Sort**   | Divides elements into buckets and sorts each bucket separately          | Best: O(n + k), Avg: O(n + k), Worst: O(n²)      | O(n + k)             | Yes         | No             | Floating-point numbers uniformly distributed                     | Great when input is uniformly distributed over a known range                   |
| Hybrid (Merge + Insertion)| **TimSort**       | Uses Insertion Sort on small runs and Merge Sort to combine them        | Best: O(n), Avg: O(n log n), Worst: O(n log n)   | O(n)                 | Yes         | No             | Python/Java default sort, real-world large datasets              | Very practical hybrid sort optimized for real-world patterns                    |


### Priority Queue Interface (Subset of Set Interface)

| Data Structure          | `build(A)` | `insert(x)` | `delete_min()` | `delete_max()` | Time Complexity | In-place? | Sorting Algorithm | Use Case Example                               | Why Use It                                                                 |
|-------------------------|------------|-------------|----------------|----------------|------------------|-----------|--------------------|------------------------------------------------|-----------------------------------------------------------------------------|
| **Dynamic Array**        | O(n)       | O(1)        | O(n)           | O(n)           | O(n²)            | Yes       | Selection Sort      | Simple scheduler, toy priority queues           | Easy to implement, but inefficient for large or frequently changing datasets. |
| **Sorted Dynamic Array** | O(n log n) | O(1)        | O(n)           | O(n)           | O(n²)            | Yes       | Insertion Sort      | Task queue with predefined priorities           | Fast access to min/max if array is kept sorted; insert/delete are expensive. |
| **Set AVL Tree**         | O(n log n) | O(log n)    | O(log n)       | O(log n)       | O(n log n)       | No        | AVL Sort            | Real-time event system, live scoreboards        | Keeps elements always ordered; supports efficient priority operations.        |
| **Binary Heap**   | O(n)       | O(log n)    | O(log n)       | O(log n)       | O(n log n)       | Yes       | Heap Sort           | CPU task scheduling, pathfinding (e.g. A*)      | Optimal balance of speed and memory for most priority queue use cases.       |